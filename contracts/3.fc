{- 
  TASK 3 - Find and replace binary substring
  Binary string is represented as a cell linked list: string splitted to chunks,
  first chunk stored to the root cell, next one to the cell in ref and so on;
  each cell can have only one ref. 
  Write the method that find and replaces one flags in the binary string
  with another value. Flags and values can be can be of any length, but
  strictly up to 128 bits. The method must replace every flag it finds.
  Flag and the value to be replaced is guaranteed to be greater than 0.
  Lets give a simple example. We have the target flag 101110101 and the value
  to be written 111111111 as inputs, and a linked list of cells, in which the bit
  value of the first cell ends with ...10100001011, and in the ref we have cell that
  starts with 10101000111111...
  The output should be a linked list where the first
  cell ends with ...10100001111, and the second cell starts with 11111000111111...
-}

() recv_internal() {
}

int can_store_bits?(builder b, int bits) asm "BCHKBITSQ";

(slice, slice) load_bit(slice cs) asm( -> 1 0) "1 LDSLICE";

int ubitsize(int x) asm "UBITSIZE"; 

global slice value;

builder solve_asm(int flat, slice text) asm """
  //  f t
  OVER UBITSIZE	// f t fl

  PUSHNULL NEWC	// f t fl blds res

  AGAINBRK:<{
    // f t fl blds res
    2OVER	LDUXQ	IFNOTRETALT
    // f t fl blds res x t'
    
    s1 s6 XCPU	//  f t fl blds res t' x f

    EQUAL	//  f t fl blds res t' _15
    IF:<{	//  f t fl blds res t'
      s4 POP	//  f t' fl blds res
      value GETGLOB	//  f t fl blds res v
    }>ELSE<{	//  f t fl blds res t'
      DROP	//  f t fl blds res
      s0 s3 XCHG	//  f res fl blds t
      1 LDSLICE	//  f res fl blds v t
      s4 s4 XCHG2	//  f t fl blds res v
    }>
    
    // f t fl blds res v
    STSLICERQ // .. res v -1 or res' 0
    IF:<{ 
      s0 s2 XCHG CONS	// v blds
      NEWC ROT // .. blds res v
      STSLICER // .. blds res
    }>
  }> DROP //  f t fl blds res


  s3 PUSH	SREFS	
  IF:<{	//  f t fl blds res
    s0 s3 XCHG LDREFRTOS	//  f res fl blds t nxt
    DUP	SBITS	//  f res fl blds t nxt nlen
    
    s4 s(-1) PUXC	SUB	
    1 PUSHINT	MAX	//  f res fl blds t nxt ll

    WHILE:<{
      s2 PUSH	SBITS	
      OVER GEQ	
    }>DO<{	//  f res fl blds t nxt ll
      s2 PUSH	SBITS	//  f res fl blds t nxt ll tlen

      s5 s0 PUSH2	SUB	//  f res fl blds t nxt ll tlen cnt

      s4 s1 PUXC PLDUX	//  f res fl blds t nxt ll cnt xu

      s3 s1 PUSH2	LDUX	//  f res fl blds t nxt ll cnt xu xl nxt'
      s2 s3 XCHG2	LSHIFT ADD	//  f res fl blds t nxt ll nxt' x

      s8 PUSH	EQUAL	
      IF:<{	//  f res fl blds t nxt ll nxt'
        2 1 BLKDROP2	//  f res fl blds t nxt'
        value GETGLOB	//  f res fl blds t nxt v
        10 PUSHPOW2	//  f res fl blds t nxt v ll=1024
      }>ELSE<{	//  f res fl blds t nxt ll nxt'
        DROP	//  f res fl blds t nxt ll
        s0 s2 XCHG	//  f res fl blds ll nxt t
        1 LDSLICE	//  f res fl blds ll nxt v t
        s3 s3 XCHG2	//  f res fl blds t nxt ll v
      }>

      //  f res fl blds t nxt ll v
      6 ROLL SWAP // f fl blds t nxt ll res v
      STSLICERQ // .. res v -1 or res' 0
      IF:<{
        // f fl blds t nxt ll res v
        s0 s5 XCHG CONS	// f fl v t nxt ll blds
        s0 s4 XCHG // f fl blds t nxt ll v
        NEWC STSLICE
      }> // f fl blds t nxt ll res'
      5 -ROLL // f res' fl blds t nxt ll
    }> DROP	s3 POP	//  f res nxt blds t

    DUP	SBITS	0 GTINT
    IF:<{	//  f res nxt blds t
      DUP	//  f res nxt blds t t
      SBITS	//  f res nxt blds t _68
      s4 s(-1) PUXC	//  f res nxt blds t res _68
      BCHKBITSQ	//  f res nxt blds t _69
      IFNOT:<{	//  f res nxt blds t
        s3 s3 XCHG2	//  f t nxt res blds
        CONS	//  f t nxt blds
        NEWC	//  f t nxt blds res
        s0 s3 XCHG	//  f res nxt blds t
      }>	//  f res nxt blds t
      s1 s3 XCHG	//  f blds nxt res t
      STSLICER	//  f blds nxt res
      s0 s2 XCHG	//  f res nxt blds
    }>ELSE<{
      DROP	//  f res nxt blds
    }>

    s3 s3 XCHG2	//  blds res f nxt
    solve CALLDICT	//  blds res res'
    DUP	//  blds res res' res'
    BBITS	//  blds res res' _75
    s2 s(-1) PUXC	//  blds res res' res _75
    BCHKBITSQ	//  blds res res' _76
    IFNOT:<{	//  blds res res'
      s0 s2 XCHG	//  res' res blds
      CONS	//  res' blds
      NEWC
      ROT	//  blds res res'
    }>	//  blds res res'
    STBR	//  blds res
  }>ELSE<{	//  f t fl blds res
    s2 POP
    s3 POP	//  blds t res
    OVER	//  blds t res t
    SBITS	//  blds t res _25
    s1 s(-1) PUXC	//  blds t res res _25
    BCHKBITSQ	//  blds t res _26
    IFNOT:<{	//  blds t res
      ROT	//  t res blds
      CONS	//  t blds
      SWAP
      NEWC	//  blds t res
    }>	//  blds t res
    SWAP	//  blds res t
    STSLICER	//  blds res
  }>

  WHILE:<{
    OVER	//  blds res blds
    ISNULL	//  blds res _81
    NOT	//  blds res _82
  }>DO<{	//  blds res
    SWAP	//  res blds
    UNCONS	//  res res' blds
    s0 s2 XCHG	//  blds res' res
    ENDC	//  blds res' _86
    SWAP	//  blds _86 res'
    STREF	//  blds res
  }>	//  blds res
  NIP	//  res
""";

builder solve(int flag, slice text) {
  return solve_asm(flag, text);
}

;; testable
(cell) find_and_replace(int flag, int _value, cell linked_list) method_id {
  value = begin_cell().store_uint(_value, ubitsize(_value)).end_cell().begin_parse();

  builder res = solve(flag, linked_list.begin_parse());

  return res.end_cell();
}

